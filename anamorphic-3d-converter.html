<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è£¸çœ¼3D Lå‹æ ¡æ­£å·¥å…·</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', sans-serif;
            background: #0a0a12;
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
        }
        
        .app {
            display: grid;
            grid-template-columns: 320px 1fr;
            height: 100vh;
        }
        
        .sidebar {
            background: rgba(0,0,0,0.6);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255,255,255,0.1);
        }
        
        h1 {
            font-size: 1.2em;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #00d4ff, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle { font-size: 0.75em; color: #64748b; margin-bottom: 20px; }
        
        .section { margin-bottom: 20px; }
        
        .section-title {
            font-size: 0.7em;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 8px;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #00d4ff, #a855f7);
            color: white;
        }
        
        .btn-primary:hover { transform: translateY(-2px); box-shadow: 0 5px 20px rgba(0,212,255,0.3); }
        
        .btn-secondary {
            background: rgba(255,255,255,0.1);
            color: white;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .btn-project {
            background: linear-gradient(135deg, #f59e0b, #ef4444);
            color: white;
            padding: 14px;
            font-size: 1em;
        }
        
        .upload-btn {
            width: 100%;
            padding: 16px;
            background: rgba(0,212,255,0.1);
            border: 2px dashed rgba(0,212,255,0.4);
            border-radius: 10px;
            color: #fff;
            cursor: pointer;
        }
        
        .upload-btn:hover { background: rgba(0,212,255,0.2); border-color: #00d4ff; }
        
        .file-info {
            font-size: 0.8em;
            color: #4ade80;
            padding: 8px;
            background: rgba(0,0,0,0.3);
            border-radius: 6px;
            margin: 10px 0;
        }
        
        .control { margin-bottom: 12px; }
        
        .control label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            margin-bottom: 5px;
        }
        
        .control .val { color: #00d4ff; font-family: monospace; }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #334155;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #00d4ff, #a855f7);
            cursor: pointer;
        }
        
        .steps {
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 12px;
        }
        
        .step {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            font-size: 0.85em;
            color: #94a3b8;
        }
        
        .step:last-child { border-bottom: none; }
        
        .step.active { color: #00d4ff; }
        .step.done { color: #4ade80; }
        
        .step-num {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .step.active .step-num { background: #00d4ff; color: #000; }
        .step.done .step-num { background: #4ade80; color: #000; }
        
        .point-list {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        
        .point-item {
            background: rgba(255,255,255,0.05);
            padding: 8px;
            border-radius: 6px;
            font-size: 0.8em;
        }
        
        .point-item.set { background: rgba(0,212,255,0.15); border: 1px solid rgba(0,212,255,0.3); }
        
        .point-label { color: #64748b; margin-bottom: 4px; }
        .point-coords { font-family: monospace; color: #00d4ff; }
        
        /* ä¸»ç•«å¸ƒå€ */
        .main {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a12 100%);
        }
        
        #canvas3d {
            cursor: crosshair;
        }
        
        .hint {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.9em;
            z-index: 10;
        }
        
        .hint.highlight {
            background: linear-gradient(135deg, rgba(0,212,255,0.8), rgba(168,85,247,0.8));
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse { 0%,100%{ opacity:1; } 50%{ opacity:0.7; } }
        
        /* æŠ•å½±æ¨¡å¼ */
        .projection {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 9999;
        }
        
        .projection.active { display: block; }
        
        #projCanvas {
            width: 100%;
            height: 100%;
        }
        
        .proj-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.8);
            padding: 12px 20px;
            border-radius: 25px;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 10000;
        }
        
        .projection:hover .proj-controls { opacity: 1; }
        
        .proj-controls button {
            background: rgba(255,255,255,0.15);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.85em;
        }
        
        .proj-controls button:hover { background: rgba(255,255,255,0.3); }
        .proj-controls button.exit { background: rgba(239,68,68,0.6); }

        .mode-tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }
        
        .mode-tab {
            flex: 1;
            padding: 8px 5px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            color: #94a3b8;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75em;
            text-align: center;
        }
        
        .mode-tab.active {
            background: linear-gradient(135deg, rgba(0,212,255,0.3), rgba(168,85,247,0.3));
            border-color: #00d4ff;
            color: #fff;
        }

        .video-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 25px;
        }
        
        .video-bar.show { display: flex; }
        
        .video-bar button {
            background: rgba(255,255,255,0.15);
            border: none;
            color: white;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .video-bar input[type="range"] {
            width: 150px;
        }
    </style>
</head>
<body>
    <div class="app">
        <div class="sidebar">
            <h1>ğŸ¯ è£¸çœ¼3D æ ¡æ­£å·¥å…·</h1>
            <p class="subtitle">æ¨™è¨˜ L å‹é¢æ¿è§’é»ï¼Œè‡ªå‹•è¨ˆç®—é€è¦–</p>
            
            <div class="section">
                <div class="section-title">ğŸ“ ä¾†æº</div>
                <button class="upload-btn" id="uploadBtn">ğŸ“· ä¸Šå‚³åœ–ç‰‡/å½±ç‰‡</button>
                <input type="file" id="fileInput" accept="image/*,video/*" style="display:none">
                <div class="file-info" id="fileInfo" style="display:none"></div>
            </div>
            
            <div class="section">
                <div class="section-title">ğŸ“ æ ¡æ­£æ­¥é©Ÿ</div>
                <div class="steps">
                    <div class="step active" id="step1">
                        <span class="step-num">1</span>
                        <span>é»æ“Šæ¨™è¨˜ <b>å·¦ä¸Šè§’</b></span>
                    </div>
                    <div class="step" id="step2">
                        <span class="step-num">2</span>
                        <span>é»æ“Šæ¨™è¨˜ <b>ä¸­ä¸Š (è½‰è§’)</b></span>
                    </div>
                    <div class="step" id="step3">
                        <span class="step-num">3</span>
                        <span>é»æ“Šæ¨™è¨˜ <b>å³ä¸Šè§’</b></span>
                    </div>
                    <div class="step" id="step4">
                        <span class="step-num">4</span>
                        <span>é»æ“Šæ¨™è¨˜ <b>å·¦ä¸‹è§’</b></span>
                    </div>
                    <div class="step" id="step5">
                        <span class="step-num">5</span>
                        <span>é»æ“Šæ¨™è¨˜ <b>ä¸­ä¸‹ (è½‰è§’)</b></span>
                    </div>
                    <div class="step" id="step6">
                        <span class="step-num">6</span>
                        <span>é»æ“Šæ¨™è¨˜ <b>å³ä¸‹è§’</b></span>
                    </div>
                </div>
                
                <div class="point-list" id="pointList">
                    <div class="point-item" id="p0"><div class="point-label">å·¦ä¸Š</div><div class="point-coords">--</div></div>
                    <div class="point-item" id="p1"><div class="point-label">ä¸­ä¸Š</div><div class="point-coords">--</div></div>
                    <div class="point-item" id="p2"><div class="point-label">å³ä¸Š</div><div class="point-coords">--</div></div>
                    <div class="point-item" id="p3"><div class="point-label">å·¦ä¸‹</div><div class="point-coords">--</div></div>
                    <div class="point-item" id="p4"><div class="point-label">ä¸­ä¸‹</div><div class="point-coords">--</div></div>
                    <div class="point-item" id="p5"><div class="point-label">å³ä¸‹</div><div class="point-coords">--</div></div>
                </div>
                
                <button class="btn btn-secondary" id="resetPointsBtn" style="margin-top:10px">ğŸ”„ é‡ç½®æ¨™è¨˜é»</button>
            </div>
            
            <div class="section">
                <div class="section-title">ğŸ¨ æ•ˆæœå¾®èª¿</div>
                <div class="control">
                    <label>æ·±åº¦é™°å½± <span class="val" id="vDepth">30%</span></label>
                    <input type="range" id="pDepth" min="0" max="100" value="30">
                </div>
                <div class="control">
                    <label>ä¸­ç·šåå…‰ <span class="val" id="vFold">40%</span></label>
                    <input type="range" id="pFold" min="0" max="100" value="40">
                </div>
                <div class="control">
                    <label>æš—è§’ <span class="val" id="vVig">20%</span></label>
                    <input type="range" id="pVig" min="0" max="100" value="20">
                </div>
            </div>
            
            <div class="section">
                <div class="section-title">ğŸ–¥ï¸ è¼¸å‡º</div>
                <button class="btn btn-project" id="projectBtn">ğŸ¯ é€²å…¥æŠ•å½±æ¨¡å¼</button>
                <button class="btn btn-primary" id="downloadBtn">ğŸ’¾ ä¸‹è¼‰ PNG</button>
                <button class="btn btn-secondary" id="exportBtn">ğŸ¬ éŒ„è£½ WebM</button>
            </div>
        </div>
        
        <div class="main">
            <div class="hint" id="hint">ğŸ‘† åœ¨ 3D ç©ºé–“ä¸­é»æ“Šæ¨™è¨˜ L å‹é¢æ¿çš„ 6 å€‹è§’é»</div>
            <canvas id="canvas3d"></canvas>
            
            <div class="video-bar" id="videoBar">
                <button id="playBtn">â–¶ï¸</button>
                <input type="range" id="videoSeek" min="0" max="1000" value="0">
                <span id="timeDisplay" style="color:#fff;font-size:0.8em;font-family:monospace">0:00</span>
            </div>
        </div>
    </div>
    
    <!-- æŠ•å½±æ¨¡å¼ -->
    <div class="projection" id="projection">
        <canvas id="projCanvas"></canvas>
        <div class="proj-controls">
            <button id="projPlayBtn">â–¶ï¸ æ’­æ”¾</button>
            <button id="projLoopBtn">ğŸ” å¾ªç’°</button>
            <button class="exit" id="projExitBtn">âœ• é€€å‡º</button>
        </div>
    </div>

    <script>
    (function() {
        // ===== ç•«å¸ƒ =====
        const canvas = document.getElementById('canvas3d');
        const ctx = canvas.getContext('2d');
        const projCanvas = document.getElementById('projCanvas');
        const projCtx = projCanvas.getContext('2d');
        
        // ===== ç‹€æ…‹ =====
        let sourceImg = null;
        let sourceVideo = null;
        let isVideo = false;
        let isPlaying = false;
        let projectionActive = false;
        let isRecording = false;
        let mediaRecorder = null;
        let chunks = [];
        
        // 6 å€‹æ¨™è¨˜é»: [å·¦ä¸Š, ä¸­ä¸Š, å³ä¸Š, å·¦ä¸‹, ä¸­ä¸‹, å³ä¸‹]
        let points = [null, null, null, null, null, null];
        let currentStep = 0;
        let draggingPoint = -1;
        
        // åƒæ•¸
        const P = { depth: 30, fold: 40, vig: 20 };
        
        // 3D è¦–è§’
        let camRotX = 20, camRotY = -25;
        let isDraggingCam = false;
        let lastMX = 0, lastMY = 0;
        
        // ===== åˆå§‹åŒ– =====
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            setupUpload();
            setupControls();
            setupCanvas();
            setupProjection();
            setupExport();
            
            render();
        }
        
        function resizeCanvas() {
            const main = document.querySelector('.main');
            canvas.width = main.clientWidth;
            canvas.height = main.clientHeight;
        }
        
        // ===== ä¸Šå‚³ =====
        function setupUpload() {
            document.getElementById('uploadBtn').onclick = () => document.getElementById('fileInput').click();
            
            document.getElementById('fileInput').onchange = function() {
                if (this.files[0]) loadFile(this.files[0]);
            };
        }
        
        function loadFile(file) {
            const info = document.getElementById('fileInfo');
            
            if (file.type.startsWith('video/')) {
                isVideo = true;
                sourceImg = null;
                
                const video = document.createElement('video');
                video.muted = true;
                video.loop = true;
                video.playsInline = true;
                
                video.onloadeddata = () => {
                    sourceVideo = video;
                    info.textContent = 'âœ“ ' + file.name;
                    info.style.display = 'block';
                    document.getElementById('videoBar').classList.add('show');
                };
                
                video.ontimeupdate = () => {
                    if (sourceVideo && sourceVideo.duration) {
                        document.getElementById('videoSeek').value = (sourceVideo.currentTime / sourceVideo.duration) * 1000;
                        const t = sourceVideo.currentTime;
                        document.getElementById('timeDisplay').textContent = 
                            Math.floor(t/60) + ':' + String(Math.floor(t%60)).padStart(2,'0');
                    }
                };
                
                video.src = URL.createObjectURL(file);
                video.load();
            } else if (file.type.startsWith('image/')) {
                isVideo = false;
                sourceVideo = null;
                document.getElementById('videoBar').classList.remove('show');
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        sourceImg = img;
                        info.textContent = 'âœ“ ' + file.name;
                        info.style.display = 'block';
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }
        
        // ===== æ§åˆ¶ =====
        function setupControls() {
            ['pDepth', 'pFold', 'pVig'].forEach(id => {
                const el = document.getElementById(id);
                const key = id.substring(1).toLowerCase();
                el.oninput = () => {
                    P[key] = parseInt(el.value);
                    document.getElementById('v' + id.substring(1)).textContent = P[key] + '%';
                };
            });
            
            document.getElementById('resetPointsBtn').onclick = () => {
                points = [null, null, null, null, null, null];
                currentStep = 0;
                updateStepUI();
                updatePointsUI();
            };
            
            document.getElementById('playBtn').onclick = togglePlay;
            document.getElementById('videoSeek').oninput = function() {
                if (sourceVideo && sourceVideo.duration) {
                    sourceVideo.currentTime = (this.value / 1000) * sourceVideo.duration;
                }
            };
        }
        
        function togglePlay() {
            if (!sourceVideo) return;
            if (isPlaying) {
                sourceVideo.pause();
                document.getElementById('playBtn').textContent = 'â–¶ï¸';
                document.getElementById('projPlayBtn').textContent = 'â–¶ï¸ æ’­æ”¾';
            } else {
                sourceVideo.play();
                document.getElementById('playBtn').textContent = 'â¸ï¸';
                document.getElementById('projPlayBtn').textContent = 'â¸ï¸ æš«åœ';
            }
            isPlaying = !isPlaying;
        }
        
        function updateStepUI() {
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById('step' + (i + 1));
                el.classList.remove('active', 'done');
                if (i < currentStep) el.classList.add('done');
                else if (i === currentStep) el.classList.add('active');
            }
            
            const hint = document.getElementById('hint');
            const labels = ['å·¦ä¸Šè§’', 'ä¸­ä¸Š (è½‰è§’)', 'å³ä¸Šè§’', 'å·¦ä¸‹è§’', 'ä¸­ä¸‹ (è½‰è§’)', 'å³ä¸‹è§’'];
            if (currentStep < 6) {
                hint.textContent = 'ğŸ‘† é»æ“Šæ¨™è¨˜ ' + labels[currentStep];
                hint.classList.add('highlight');
            } else {
                hint.textContent = 'âœ“ æ ¡æ­£å®Œæˆï¼å¯æ‹–æ›³èª¿æ•´é»ä½';
                hint.classList.remove('highlight');
            }
        }
        
        function updatePointsUI() {
            const labels = ['å·¦ä¸Š', 'ä¸­ä¸Š', 'å³ä¸Š', 'å·¦ä¸‹', 'ä¸­ä¸‹', 'å³ä¸‹'];
            for (let i = 0; i < 6; i++) {
                const el = document.getElementById('p' + i);
                const coords = el.querySelector('.point-coords');
                if (points[i]) {
                    el.classList.add('set');
                    coords.textContent = `(${points[i].x.toFixed(0)}, ${points[i].y.toFixed(0)})`;
                } else {
                    el.classList.remove('set');
                    coords.textContent = '--';
                }
            }
        }
        
        // ===== ç•«å¸ƒäº’å‹• =====
        function setupCanvas() {
            canvas.onmousedown = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // æª¢æŸ¥æ˜¯å¦é»æ“Šåˆ°ç¾æœ‰é»
                for (let i = 0; i < 6; i++) {
                    if (points[i]) {
                        const dx = x - points[i].x;
                        const dy = y - points[i].y;
                        if (Math.sqrt(dx*dx + dy*dy) < 15) {
                            draggingPoint = i;
                            return;
                        }
                    }
                }
                
                // æ–°å¢é»
                if (currentStep < 6) {
                    points[currentStep] = { x, y };
                    currentStep++;
                    updateStepUI();
                    updatePointsUI();
                } else {
                    // æ ¡æ­£å®Œæˆå¾Œï¼Œå³éµæ‹–æ›³æ—‹è½‰è¦–è§’
                    if (e.button === 2 || e.ctrlKey) {
                        isDraggingCam = true;
                        lastMX = e.clientX;
                        lastMY = e.clientY;
                    }
                }
            };
            
            canvas.onmousemove = (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (draggingPoint >= 0) {
                    points[draggingPoint] = { x, y };
                    updatePointsUI();
                }
                
                if (isDraggingCam) {
                    camRotY += (e.clientX - lastMX) * 0.3;
                    camRotX += (e.clientY - lastMY) * 0.3;
                    camRotX = Math.max(-60, Math.min(60, camRotX));
                    lastMX = e.clientX;
                    lastMY = e.clientY;
                }
            };
            
            canvas.onmouseup = () => {
                draggingPoint = -1;
                isDraggingCam = false;
            };
            
            canvas.oncontextmenu = (e) => e.preventDefault();
        }
        
        // ===== æŠ•å½±æ¨¡å¼ =====
        function setupProjection() {
            document.getElementById('projectBtn').onclick = () => {
                projectionActive = true;
                document.getElementById('projection').classList.add('active');
                projCanvas.width = window.innerWidth;
                projCanvas.height = window.innerHeight;
                if (sourceVideo && !isPlaying) togglePlay();
            };
            
            document.getElementById('projExitBtn').onclick = () => {
                projectionActive = false;
                document.getElementById('projection').classList.remove('active');
            };
            
            document.getElementById('projPlayBtn').onclick = togglePlay;
            
            document.getElementById('projLoopBtn').onclick = function() {
                if (sourceVideo) {
                    sourceVideo.loop = !sourceVideo.loop;
                    this.textContent = sourceVideo.loop ? 'ğŸ” å¾ªç’°' : 'â¡ï¸ å–®æ¬¡';
                }
            };
            
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && projectionActive) {
                    projectionActive = false;
                    document.getElementById('projection').classList.remove('active');
                }
            });
        }
        
        // ===== åŒ¯å‡º =====
        function setupExport() {
            document.getElementById('downloadBtn').onclick = () => {
                // å‰µå»ºè¼¸å‡ºç•«å¸ƒ
                const outCanvas = document.createElement('canvas');
                const src = isVideo ? sourceVideo : sourceImg;
                if (!src) return;
                
                outCanvas.width = isVideo ? src.videoWidth : src.width;
                outCanvas.height = isVideo ? src.videoHeight : src.height;
                const outCtx = outCanvas.getContext('2d');
                
                renderTransformed(outCtx, outCanvas.width, outCanvas.height, src);
                
                const link = document.createElement('a');
                link.download = 'anamorphic-' + Date.now() + '.png';
                link.href = outCanvas.toDataURL('image/png');
                link.click();
            };
            
            document.getElementById('exportBtn').onclick = async () => {
                if (!isVideo || !sourceVideo) {
                    document.getElementById('downloadBtn').click();
                    return;
                }
                
                if (isRecording) {
                    if (mediaRecorder) mediaRecorder.stop();
                    return;
                }
                
                // å‰µå»ºè¼¸å‡ºç•«å¸ƒ
                const outCanvas = document.createElement('canvas');
                outCanvas.width = sourceVideo.videoWidth;
                outCanvas.height = sourceVideo.videoHeight;
                const outCtx = outCanvas.getContext('2d');
                
                const stream = outCanvas.captureStream(30);
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });
                
                chunks = [];
                mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };
                mediaRecorder.onstop = () => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = 'anamorphic-' + Date.now() + '.webm';
                    a.click();
                    isRecording = false;
                    document.getElementById('exportBtn').textContent = 'ğŸ¬ éŒ„è£½ WebM';
                };
                
                sourceVideo.currentTime = 0;
                await sourceVideo.play();
                isPlaying = true;
                
                // éŒ„è£½å¾ªç’°
                const recordFrame = () => {
                    if (!isRecording) return;
                    renderTransformed(outCtx, outCanvas.width, outCanvas.height, sourceVideo);
                    if (sourceVideo.ended) {
                        mediaRecorder.stop();
                    } else {
                        requestAnimationFrame(recordFrame);
                    }
                };
                
                mediaRecorder.start();
                isRecording = true;
                document.getElementById('exportBtn').textContent = 'â¹ï¸ åœæ­¢';
                recordFrame();
                
                sourceVideo.onended = () => {
                    if (isRecording && mediaRecorder) mediaRecorder.stop();
                };
            };
        }
        
        // ===== æ¸²æŸ“ =====
        function render() {
            // æ¸…é™¤
            ctx.fillStyle = '#12121f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ç¹ªè£½ç¶²æ ¼èƒŒæ™¯
            drawGrid(ctx, canvas.width, canvas.height);
            
            // å–å¾—ä¾†æº
            const src = isVideo ? sourceVideo : sourceImg;
            
            // å¦‚æœæœ‰è¶³å¤ çš„é»ï¼Œç¹ªè£½è®Šå½¢é è¦½
            if (src && points[0] && points[1] && points[2] && points[3] && points[4] && points[5]) {
                drawTransformedPreview(ctx, src);
            }
            
            // ç¹ªè£½æ¨™è¨˜é»å’Œé€£ç·š
            drawPoints(ctx);
            
            // æŠ•å½±æ¨¡å¼
            if (projectionActive && src) {
                projCanvas.width = window.innerWidth;
                projCanvas.height = window.innerHeight;
                projCtx.fillStyle = '#000';
                projCtx.fillRect(0, 0, projCanvas.width, projCanvas.height);
                
                // åœ¨æŠ•å½±æ¨¡å¼ä¸­ç¹ªè£½è®Šå½¢å¾Œçš„å…§å®¹
                if (points.every(p => p !== null)) {
                    renderTransformedFullscreen(projCtx, projCanvas.width, projCanvas.height, src);
                }
            }
            
            requestAnimationFrame(render);
        }
        
        function drawGrid(c, w, h) {
            c.strokeStyle = 'rgba(255,255,255,0.05)';
            c.lineWidth = 1;
            
            const step = 50;
            for (let x = 0; x < w; x += step) {
                c.beginPath();
                c.moveTo(x, 0);
                c.lineTo(x, h);
                c.stroke();
            }
            for (let y = 0; y < h; y += step) {
                c.beginPath();
                c.moveTo(0, y);
                c.lineTo(w, y);
                c.stroke();
            }
        }
        
        function drawPoints(c) {
            const colors = ['#ff6b6b', '#ffd93d', '#6bcb77', '#ff6b6b', '#ffd93d', '#6bcb77'];
            const labels = ['TL', 'TM', 'TR', 'BL', 'BM', 'BR'];
            
            // ç¹ªè£½é€£ç·š
            c.strokeStyle = 'rgba(0,212,255,0.5)';
            c.lineWidth = 2;
            
            // ä¸Šé‚Š
            if (points[0] && points[1]) { c.beginPath(); c.moveTo(points[0].x, points[0].y); c.lineTo(points[1].x, points[1].y); c.stroke(); }
            if (points[1] && points[2]) { c.beginPath(); c.moveTo(points[1].x, points[1].y); c.lineTo(points[2].x, points[2].y); c.stroke(); }
            
            // ä¸‹é‚Š
            if (points[3] && points[4]) { c.beginPath(); c.moveTo(points[3].x, points[3].y); c.lineTo(points[4].x, points[4].y); c.stroke(); }
            if (points[4] && points[5]) { c.beginPath(); c.moveTo(points[4].x, points[4].y); c.lineTo(points[5].x, points[5].y); c.stroke(); }
            
            // å´é‚Š
            c.strokeStyle = 'rgba(168,85,247,0.5)';
            if (points[0] && points[3]) { c.beginPath(); c.moveTo(points[0].x, points[0].y); c.lineTo(points[3].x, points[3].y); c.stroke(); }
            if (points[1] && points[4]) { c.beginPath(); c.moveTo(points[1].x, points[1].y); c.lineTo(points[4].x, points[4].y); c.stroke(); }
            if (points[2] && points[5]) { c.beginPath(); c.moveTo(points[2].x, points[2].y); c.lineTo(points[5].x, points[5].y); c.stroke(); }
            
            // ç¹ªè£½é»
            for (let i = 0; i < 6; i++) {
                if (points[i]) {
                    // å¤–åœˆ
                    c.beginPath();
                    c.arc(points[i].x, points[i].y, 12, 0, Math.PI * 2);
                    c.fillStyle = colors[i];
                    c.fill();
                    
                    // å…§åœˆ
                    c.beginPath();
                    c.arc(points[i].x, points[i].y, 6, 0, Math.PI * 2);
                    c.fillStyle = '#fff';
                    c.fill();
                    
                    // æ¨™ç±¤
                    c.fillStyle = '#fff';
                    c.font = 'bold 10px sans-serif';
                    c.textAlign = 'center';
                    c.fillText(labels[i], points[i].x, points[i].y - 20);
                }
            }
            
            // ç¹ªè£½ä¸‹ä¸€å€‹é»çš„é è¦½ä½ç½®
            if (currentStep < 6) {
                c.fillStyle = 'rgba(255,255,255,0.3)';
                c.font = '14px sans-serif';
                c.textAlign = 'center';
                const labels2 = ['å·¦ä¸Šè§’', 'ä¸­ä¸Š (è½‰è§’)', 'å³ä¸Šè§’', 'å·¦ä¸‹è§’', 'ä¸­ä¸‹ (è½‰è§’)', 'å³ä¸‹è§’'];
                c.fillText('é»æ“Šæ¨™è¨˜: ' + labels2[currentStep], canvas.width / 2, canvas.height - 30);
            }
        }
        
        function drawTransformedPreview(c, src) {
            // ç¹ªè£½å·¦é¢æ¿ (é» 0,1,3,4)
            drawQuad(c, src, 
                points[0], points[1], points[4], points[3],
                0, 0, 0.5, 1
            );
            
            // ç¹ªè£½å³é¢æ¿ (é» 1,2,4,5)
            drawQuad(c, src,
                points[1], points[2], points[5], points[4],
                0.5, 0, 1, 1
            );
            
            // ä¸­ç·šæ•ˆæœ
            const midX = (points[1].x + points[4].x) / 2;
            const midTopY = points[1].y;
            const midBotY = points[4].y;
            
            const foldW = 20 + P.fold * 0.5;
            const grad = c.createLinearGradient(midX - foldW, 0, midX + foldW, 0);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.4, `rgba(0,0,0,${P.depth / 200})`);
            grad.addColorStop(0.5, `rgba(255,255,255,${P.fold / 400})`);
            grad.addColorStop(0.6, `rgba(0,0,0,${P.depth / 200})`);
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            
            c.fillStyle = grad;
            c.beginPath();
            c.moveTo(points[1].x - foldW, points[1].y);
            c.lineTo(points[1].x + foldW, points[1].y);
            c.lineTo(points[4].x + foldW, points[4].y);
            c.lineTo(points[4].x - foldW, points[4].y);
            c.closePath();
            c.fill();
        }
        
        // ç¹ªè£½å››é‚Šå½¢è®Šå½¢
        function drawQuad(c, src, p0, p1, p2, p3, u0, v0, u1, v1) {
            const srcW = isVideo ? src.videoWidth : src.width;
            const srcH = isVideo ? src.videoHeight : src.height;
            
            // ä½¿ç”¨ç´°åˆ†ç¶²æ ¼ç¹ªè£½
            const divisions = 20;
            
            for (let i = 0; i < divisions; i++) {
                for (let j = 0; j < divisions; j++) {
                    const t0 = i / divisions;
                    const t1 = (i + 1) / divisions;
                    const s0 = j / divisions;
                    const s1 = (j + 1) / divisions;
                    
                    // é›™ç·šæ€§æ’å€¼ç›®æ¨™é»
                    const lerp = (a, b, t) => a + (b - a) * t;
                    const bilinear = (t, s) => ({
                        x: lerp(lerp(p0.x, p1.x, t), lerp(p3.x, p2.x, t), s),
                        y: lerp(lerp(p0.y, p1.y, t), lerp(p3.y, p2.y, t), s)
                    });
                    
                    const q0 = bilinear(t0, s0);
                    const q1 = bilinear(t1, s0);
                    const q2 = bilinear(t1, s1);
                    const q3 = bilinear(t0, s1);
                    
                    // ä¾†æº UV
                    const su0 = lerp(u0, u1, t0) * srcW;
                    const su1 = lerp(u0, u1, t1) * srcW;
                    const sv0 = lerp(v0, v1, s0) * srcH;
                    const sv1 = lerp(v0, v1, s1) * srcH;
                    
                    // ç¹ªè£½å°å¡Š
                    c.save();
                    c.beginPath();
                    c.moveTo(q0.x, q0.y);
                    c.lineTo(q1.x, q1.y);
                    c.lineTo(q2.x, q2.y);
                    c.lineTo(q3.x, q3.y);
                    c.closePath();
                    c.clip();
                    
                    // è¨ˆç®—ä»¿å°„è®Šæ›
                    const dx = q1.x - q0.x;
                    const dy = q1.y - q0.y;
                    const ex = q3.x - q0.x;
                    const ey = q3.y - q0.y;
                    
                    c.setTransform(
                        dx / (su1 - su0), dy / (su1 - su0),
                        ex / (sv1 - sv0), ey / (sv1 - sv0),
                        q0.x - su0 * dx / (su1 - su0) - sv0 * ex / (sv1 - sv0),
                        q0.y - su0 * dy / (su1 - su0) - sv0 * ey / (sv1 - sv0)
                    );
                    
                    c.drawImage(src, 0, 0);
                    c.restore();
                }
            }
        }
        
        function renderTransformed(c, w, h, src) {
            c.fillStyle = '#000';
            c.fillRect(0, 0, w, h);
            
            if (!points.every(p => p !== null)) {
                c.drawImage(src, 0, 0, w, h);
                return;
            }
            
            // å°‡æ¨™è¨˜é»è½‰æ›ç‚ºè¼¸å‡ºæ¯”ä¾‹
            const scaleX = w / canvas.width;
            const scaleY = h / canvas.height;
            
            const scaledPoints = points.map(p => ({
                x: p.x * scaleX,
                y: p.y * scaleY
            }));
            
            // å·¦é¢æ¿
            drawQuadScaled(c, src, 
                scaledPoints[0], scaledPoints[1], scaledPoints[4], scaledPoints[3],
                0, 0, 0.5, 1
            );
            
            // å³é¢æ¿
            drawQuadScaled(c, src,
                scaledPoints[1], scaledPoints[2], scaledPoints[5], scaledPoints[4],
                0.5, 0, 1, 1
            );
        }
        
        function drawQuadScaled(c, src, p0, p1, p2, p3, u0, v0, u1, v1) {
            const srcW = isVideo ? src.videoWidth : src.width;
            const srcH = isVideo ? src.videoHeight : src.height;
            const divisions = 30;
            
            for (let i = 0; i < divisions; i++) {
                for (let j = 0; j < divisions; j++) {
                    const t0 = i / divisions;
                    const t1 = (i + 1) / divisions;
                    const s0 = j / divisions;
                    const s1 = (j + 1) / divisions;
                    
                    const lerp = (a, b, t) => a + (b - a) * t;
                    const bilinear = (t, s) => ({
                        x: lerp(lerp(p0.x, p1.x, t), lerp(p3.x, p2.x, t), s),
                        y: lerp(lerp(p0.y, p1.y, t), lerp(p3.y, p2.y, t), s)
                    });
                    
                    const q0 = bilinear(t0, s0);
                    const q1 = bilinear(t1, s0);
                    const q2 = bilinear(t1, s1);
                    const q3 = bilinear(t0, s1);
                    
                    const su0 = lerp(u0, u1, t0) * srcW;
                    const su1 = lerp(u0, u1, t1) * srcW;
                    const sv0 = lerp(v0, v1, s0) * srcH;
                    const sv1 = lerp(v0, v1, s1) * srcH;
                    
                    c.save();
                    c.beginPath();
                    c.moveTo(q0.x, q0.y);
                    c.lineTo(q1.x, q1.y);
                    c.lineTo(q2.x, q2.y);
                    c.lineTo(q3.x, q3.y);
                    c.closePath();
                    c.clip();
                    
                    const dx = q1.x - q0.x;
                    const dy = q1.y - q0.y;
                    const ex = q3.x - q0.x;
                    const ey = q3.y - q0.y;
                    
                    c.setTransform(
                        dx / (su1 - su0), dy / (su1 - su0),
                        ex / (sv1 - sv0), ey / (sv1 - sv0),
                        q0.x - su0 * dx / (su1 - su0) - sv0 * ex / (sv1 - sv0),
                        q0.y - su0 * dy / (su1 - su0) - sv0 * ey / (sv1 - sv0)
                    );
                    
                    c.drawImage(src, 0, 0);
                    c.restore();
                }
            }
        }
        
        function renderTransformedFullscreen(c, w, h, src) {
            // æŠ•å½±æ¨¡å¼ï¼šå¡«æ»¿æ•´å€‹è¢å¹•
            const srcW = isVideo ? src.videoWidth : src.width;
            const srcH = isVideo ? src.videoHeight : src.height;
            
            // è¨ˆç®—ç¸®æ”¾ä»¥å¡«æ»¿è¢å¹•
            const scale = Math.max(w / srcW, h / srcH);
            const drawW = srcW * scale;
            const drawH = srcH * scale;
            const offsetX = (w - drawW) / 2;
            const offsetY = (h - drawH) / 2;
            
            // å°‡æ¨™è¨˜é»å¾ç•«å¸ƒåº§æ¨™è½‰æ›ç‚ºå…¨è¢å¹•åº§æ¨™
            const canvasToScreen = (p) => ({
                x: offsetX + (p.x / canvas.width) * drawW,
                y: offsetY + (p.y / canvas.height) * drawH
            });
            
            const screenPoints = points.map(canvasToScreen);
            
            // å·¦é¢æ¿
            drawQuadScaled(c, src,
                screenPoints[0], screenPoints[1], screenPoints[4], screenPoints[3],
                0, 0, 0.5, 1
            );
            
            // å³é¢æ¿
            drawQuadScaled(c, src,
                screenPoints[1], screenPoints[2], screenPoints[5], screenPoints[4],
                0.5, 0, 1, 1
            );
        }
        
        // å•Ÿå‹•
        init();
    })();
    </script>
</body>
</html>